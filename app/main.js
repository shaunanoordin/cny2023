/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/avo/avo.js":
/*!************************!*\
  !*** ./src/avo/avo.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AvO)\n/* harmony export */ });\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_physics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/physics */ \"./src/avo/physics.js\");\n/* harmony import */ var _avo_levels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/levels */ \"./src/avo/levels.js\");\n/* harmony import */ var _avo_image_asset__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/image-asset */ \"./src/avo/image-asset.js\");\n/* harmony import */ var _avo_json_asset__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @avo/json-asset */ \"./src/avo/json-asset.js\");\n/* harmony import */ var _avo_interaction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @avo/interaction */ \"./src/avo/interaction/index.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\n\n\nvar searchParams = new URLSearchParams(window.location.search);\nvar DEBUG = searchParams.get('debug') || false;\nvar STARTING_LEVEL = Number.isInteger(parseInt(searchParams.get('level'))) ? parseInt(searchParams.get('level')) - 1 : 0;\n\nvar AvO = /*#__PURE__*/function () {\n  function AvO() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, AvO);\n\n    var _args$width = args.width,\n        width = _args$width === void 0 ? _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_COLS * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE : _args$width,\n        _args$height = args.height,\n        height = _args$height === void 0 ? _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_ROWS * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE : _args$height;\n    this.html = {\n      main: document.getElementById('main'),\n      canvas: document.getElementById('canvas'),\n      homeMenu: document.getElementById('home-menu'),\n      interactionMenu: document.getElementById('interaction-menu'),\n      buttonHome: document.getElementById('button-home'),\n      buttonFullscreen: document.getElementById('button-fullscreen'),\n      buttonReload: document.getElementById('button-reload'),\n      buttonArrowLeft: document.getElementById('button-arrow-left'),\n      // CNY2023\n      buttonArrowRight: document.getElementById('button-arrow-right') // CNY2023\n\n    };\n    this.homeMenu = false;\n    this.setHomeMenu(false);\n    this.interactionMenu = false;\n    this.setInteractionMenu(false);\n    this.canvas2d = this.html.canvas.getContext('2d');\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n    this._canvasHasCameraTransforms = false; // Safety check\n\n    this.camera = {\n      target: null,\n      // Target entity to follow. If null, camera is static.\n      x: 0,\n      y: 0,\n      zoom: 1\n    };\n    this.setupUI();\n    this.initialised = false;\n    this.assets = {\n      \"sprites\": new _avo_image_asset__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('assets/cny2023-sprites.png'),\n      \"win\": new _avo_image_asset__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('assets/cny2023-win.png'),\n      \"lose\": new _avo_image_asset__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('assets/cny2023-lose.png') // \"hero-4dir\": new ImageAsset('assets/avo-sprites-2022-05-samiel.png'),\n      // \"hero-2dir\": new ImageAsset('assets/avo-sprites-2022-10-samiel-2dir.png'),\n      // \"exampleImage\": new ImageAsset('assets/simple-bg.png'),\n      // \"exampleJson\": new JsonAsset('assets/example.json'),\n\n    };\n    this.secretAssets = {// \"secretImage\": new ImageAsset('secrets/simple-bg.png'),\n      // \"secretJson\": new JsonAsset('secrets/example.json'),\n    };\n    this.hero = null;\n    this.entities = [];\n    this.rules = {};\n    this.levels = new _avo_levels__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.playerAction = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_ACTIONS.IDLE;\n    this.playerInput = {\n      // Mouse/touchscreen input\n      pointerStart: undefined,\n      pointerCurrent: undefined,\n      pointerEnd: undefined,\n      // Keys that are currently being pressed.\n      // keysPressed = { key: { duration, acknowledged } }\n      keysPressed: {},\n      // CNY2023\n      buttonArrowLeftPressed: false,\n      buttonArrowRightPressed: false\n    };\n    this.prevTime = null;\n    this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n  }\n\n  _createClass(AvO, [{\n    key: \"initialisationCheck\",\n    value: function initialisationCheck() {\n      var _this = this;\n\n      // Assets check\n      var allAssetsReady = true;\n      var numReadyAssets = 0;\n      var numTotalAssets = 0;\n      Object.keys(this.assets).forEach(function (id) {\n        var asset = _this.assets[id];\n        allAssetsReady = allAssetsReady && asset.ready;\n        if (asset.ready) numReadyAssets++;\n        numTotalAssets++;\n      });\n      Object.keys(this.secretAssets).forEach(function (id) {\n        var secretAsset = _this.secretAssets[id];\n        var secretAssetIsReady = secretAsset.ready || secretAsset.error;\n        allAssetsReady = allAssetsReady && secretAssetIsReady;\n        if (secretAssetIsReady) numReadyAssets++;\n        numTotalAssets++;\n      }); // Paint status\n\n      this.canvas2d.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      this.canvas2d.textAlign = 'start';\n      this.canvas2d.textBaseline = 'top';\n      this.canvas2d.fillStyle = '#ccc';\n      this.canvas2d.font = \"1em monospace\";\n      this.canvas2d.fillText(\"Loading \".concat(numReadyAssets, \" / \").concat(numTotalAssets, \" \"), _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n\n      if (allAssetsReady) {\n        // Clean up secret assets\n        Object.keys(this.secretAssets).forEach(function (id) {\n          if (_this.secretAssets[id].error) delete _this.secretAssets[id];\n        }); // Let's go!\n\n        this.initialised = true;\n        this.showUI();\n        this.levels.load(STARTING_LEVEL);\n      }\n    }\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    The main loop. Run a single frame of gameplay.\r\n    - time: the current/total time (milliseconds) since the game started.\r\n     */\n\n  }, {\n    key: \"main\",\n    value: function main(time) {\n      var timeStep = this.prevTime ? time - this.prevTime : time;\n      this.prevTime = time;\n\n      if (this.initialised) {\n        this.play(timeStep);\n        this.paint();\n      } else {\n        this.initialisationCheck();\n      }\n\n      this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n    }\n    /*\r\n    Run the gameplay/physics logic for a single frame.\r\n    - timeStep: the time (milliseconds) since the last frame.\r\n      We expect 60 frames per second.\r\n     */\n\n  }, {\n    key: \"play\",\n    value: function play(timeStep) {\n      var _this2 = this;\n\n      // If a menu is open, pause all action gameplay\n      if (this.homeMenu || this.interactionMenu) return; // Run the action gameplay\n      // ----------------\n\n      for (var id in this.rules) {\n        this.rules[id].play(timeStep);\n      }\n\n      this.entities.forEach(function (entity) {\n        return entity.play(timeStep);\n      });\n      this.checkCollisions(timeStep); // Cleanup\n\n      this.entities = this.entities.filter(function (entity) {\n        return !entity._expired;\n      });\n\n      for (var _id in this.rules) {\n        if (this.rules[_id]._expired) delete this.rules[_id];\n      } // Sort Entities along the y-axis, for paint()/rendering purposes.\n      // WARNING: inefficient\n\n\n      this.entities.sort(function (a, b) {\n        return a.y - b.y;\n      }); // ----------------\n      // Increment the duration of each currently pressed key\n\n      Object.keys(this.playerInput.keysPressed).forEach(function (key) {\n        if (_this2.playerInput.keysPressed[key]) _this2.playerInput.keysPressed[key].duration += timeStep;\n      });\n    }\n    /*\r\n    Paint/draw the game visuals onto the canvas.\r\n     */\n\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var _this3 = this;\n\n      var c2d = this.canvas2d;\n      var camera = this.camera; // Camera Controls: focus the camera on the target entity, if any.\n      // ----------------\n\n      if (camera.target) {\n        camera.x = this.canvasWidth / 2 - camera.target.x * camera.zoom;\n        camera.y = this.canvasHeight / 2 - camera.target.y * camera.zoom;\n      }\n\n      c2d.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      c2d.resetTransform();\n      c2d.strokeStyle = 'rgba(128, 128, 128, 0.05)';\n      c2d.lineWidth = 2; // ----------------\n      // Draw grid\n      // ----------------\n\n      var GRID_SIZE = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * camera.zoom;\n      var offsetX = this.camera.x % GRID_SIZE - GRID_SIZE;\n      var offsetY = this.camera.y % GRID_SIZE - GRID_SIZE;\n\n      for (var y = offsetY; y < this.canvasHeight; y += GRID_SIZE) {\n        for (var x = offsetX; x < this.canvasWidth; x += GRID_SIZE) {\n          c2d.beginPath();\n          c2d.rect(x, y, GRID_SIZE, GRID_SIZE);\n          c2d.stroke(); // Debug Grid\n\n          if (DEBUG) {\n            c2d.fillStyle = '#ccc';\n            c2d.font = \"\".concat(camera.zoom * 0.5, \"em Source Code Pro\");\n            c2d.textAlign = 'center';\n            c2d.textBaseline = 'middle';\n            var col = Math.floor((x - this.camera.x) / GRID_SIZE);\n            var row = Math.floor((y - this.camera.y) / GRID_SIZE);\n            c2d.fillText(col + ',' + row, x + GRID_SIZE / 2, y + GRID_SIZE / 2); // using template strings here messes up colours in Brackets.\n          }\n        }\n      } // ----------------\n      // Draw entities and other elements\n      // ----------------\n\n\n      var _loop = function _loop(layer) {\n        _this3.entities.forEach(function (entity) {\n          return entity.paint(layer);\n        });\n\n        for (var id in _this3.rules) {\n          _this3.rules[id].paint(layer);\n        }\n      };\n\n      for (var layer = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.MIN_LAYER; layer <= _avo_constants__WEBPACK_IMPORTED_MODULE_0__.MAX_LAYER; layer++) {\n        _loop(layer);\n      } // ----------------\n      // Draw player input\n      // ----------------\n\n\n      if (this.playerAction === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_ACTIONS.POINTER_DOWN && this.hero && this.playerInput.pointerCurrent) {\n        var inputCoords = this.playerInput.pointerCurrent;\n        c2d.strokeStyle = '#888';\n        c2d.lineWidth = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 8;\n        c2d.beginPath();\n        c2d.arc(inputCoords.x, inputCoords.y, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE, 0, 2 * Math.PI);\n        c2d.stroke();\n      } // ----------------\n\n    }\n    /*\r\n    Section: UI and Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n  }, {\n    key: \"setupUI\",\n    value: function setupUI() {\n      this.html.canvas.width = this.canvasWidth;\n      this.html.canvas.height = this.canvasHeight;\n      this.canvas2d.imageSmoothingEnabled = false;\n      /* Pixel art: Maintains sprites' pixel sharpness when scaled up via drawImage() */\n\n      if (window.PointerEvent) {\n        this.html.canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));\n        this.html.canvas.addEventListener('pointermove', this.onPointerMove.bind(this));\n        this.html.canvas.addEventListener('pointerup', this.onPointerUp.bind(this));\n        this.html.canvas.addEventListener('pointercancel', this.onPointerUp.bind(this));\n      } else {\n        this.html.canvas.addEventListener('mousedown', this.onPointerDown.bind(this));\n        this.html.canvas.addEventListener('mousemove', this.onPointerMove.bind(this));\n        this.html.canvas.addEventListener('mouseup', this.onPointerUp.bind(this));\n      } // Prevent \"touch and hold to open context menu\" menu on touchscreens.\n\n\n      this.html.canvas.addEventListener('touchstart', stopEvent);\n      this.html.canvas.addEventListener('touchmove', stopEvent);\n      this.html.canvas.addEventListener('touchend', stopEvent);\n      this.html.canvas.addEventListener('touchcancel', stopEvent);\n      this.html.buttonHome.addEventListener('click', this.buttonHome_onClick.bind(this));\n      this.html.buttonFullscreen.addEventListener('click', this.buttonFullscreen_onClick.bind(this));\n      this.html.buttonReload.addEventListener('click', this.buttonReload_onClick.bind(this));\n      this.html.main.addEventListener('keydown', this.onKeyDown.bind(this));\n      this.html.main.addEventListener('keyup', this.onKeyUp.bind(this));\n      window.addEventListener('resize', this.updateUI.bind(this));\n      this.updateUI();\n      this.hideUI(); // Hide until all assets are ready\n      // CNY2023\n      // --------\n\n      if (window.PointerEvent) {\n        this.html.buttonArrowLeft.addEventListener('pointerdown', this.buttonArrowLeft_onDown.bind(this));\n        this.html.buttonArrowLeft.addEventListener('pointerup', this.buttonArrowLeft_onUp.bind(this));\n        this.html.buttonArrowRight.addEventListener('pointerdown', this.buttonArrowRight_onDown.bind(this));\n        this.html.buttonArrowRight.addEventListener('pointerup', this.buttonArrowRight_onUp.bind(this));\n      } else {\n        this.html.buttonArrowLeft.addEventListener('mousedown', this.buttonArrowLeft_onDown.bind(this));\n        this.html.buttonArrowLeft.addEventListener('mouseup', this.buttonArrowLeft_onUp.bind(this));\n        this.html.buttonArrowRight.addEventListener('mousedown', this.buttonArrowRight_onDown.bind(this));\n        this.html.buttonArrowRight.addEventListener('mouseup', this.buttonArrowRight_onUp.bind(this));\n      }\n\n      this.html.buttonArrowLeft.addEventListener('touchstart', stopEvent);\n      this.html.buttonArrowLeft.addEventListener('touchmove', stopEvent);\n      this.html.buttonArrowLeft.addEventListener('touchend', stopEvent);\n      this.html.buttonArrowLeft.addEventListener('touchcancel', stopEvent);\n      this.html.buttonArrowRight.addEventListener('touchstart', stopEvent);\n      this.html.buttonArrowRight.addEventListener('touchmove', stopEvent);\n      this.html.buttonArrowRight.addEventListener('touchend', stopEvent);\n      this.html.buttonArrowRight.addEventListener('touchcancel', stopEvent); // --------\n\n      this.html.main.focus();\n    }\n  }, {\n    key: \"hideUI\",\n    value: function hideUI() {\n      this.html.buttonHome.style.visibility = 'hidden';\n      this.html.buttonReload.style.visibility = 'hidden';\n    }\n  }, {\n    key: \"showUI\",\n    value: function showUI() {\n      this.html.buttonHome.style.visibility = 'visible';\n      this.html.buttonReload.style.visibility = 'visible';\n    }\n  }, {\n    key: \"updateUI\",\n    value: function updateUI() {\n      // Fit the interaction layers (menus, etc) to the canvas\n      var mainDivBounds = this.html.main.getBoundingClientRect();\n      var canvasBounds = this.html.canvas.getBoundingClientRect();\n      this.html.homeMenu.style.width = \"\".concat(canvasBounds.width, \"px\");\n      this.html.homeMenu.style.height = \"\".concat(canvasBounds.height, \"px\");\n      this.html.homeMenu.style.top = \"\".concat(canvasBounds.top - mainDivBounds.top, \"px\");\n      this.html.homeMenu.style.left = \"\".concat(canvasBounds.left, \"px\");\n      this.html.interactionMenu.style.width = \"\".concat(canvasBounds.width, \"px\");\n      this.html.interactionMenu.style.height = \"\".concat(canvasBounds.height, \"px\");\n      this.html.interactionMenu.style.top = \"\".concat(canvasBounds.top - mainDivBounds.top, \"px\");\n      this.html.interactionMenu.style.left = \"\".concat(canvasBounds.left, \"px\");\n    }\n  }, {\n    key: \"setHomeMenu\",\n    value: function setHomeMenu(homeMenu) {\n      this.homeMenu = homeMenu;\n\n      if (homeMenu) {\n        this.html.homeMenu.style.visibility = 'visible';\n        this.html.buttonReload.style.visibility = 'hidden';\n      } else {\n        this.html.homeMenu.style.visibility = 'hidden';\n        this.html.buttonReload.style.visibility = 'visible';\n        this.html.main.focus();\n      }\n    }\n  }, {\n    key: \"setInteractionMenu\",\n    value: function setInteractionMenu(interactionMenu) {\n      var div = this.html.interactionMenu;\n      this.interactionMenu && this.interactionMenu.unload(); // Unload the old menu, if any\n\n      this.interactionMenu = interactionMenu; // Set the new menu\n\n      if (interactionMenu) {\n        while (div.firstChild) {\n          div.removeChild(div.firstChild);\n        } // Clear div\n\n\n        interactionMenu.load(div); // load the new menu\n\n        div.style.visibility = 'visible';\n      } else {\n        div.style.visibility = 'hidden';\n        this.html.main.focus();\n      }\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n      this.playerAction = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_ACTIONS.POINTER_DOWN;\n      this.playerInput.pointerStart = coords;\n      this.playerInput.pointerCurrent = coords;\n      this.playerInput.pointerEnd = undefined;\n      this.html.main.focus();\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n      this.playerInput.pointerCurrent = coords;\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n\n      if (this.playerAction === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_ACTIONS.POINTER_DOWN) {\n        this.playerInput.pointerEnd = coords;\n        this.playerAction = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_ACTIONS.IDLE;\n      }\n\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(e) {\n      var _this$hero, _this$hero2;\n\n      // Special cases\n      switch (e.key) {\n        // Open home menu\n        case 'Escape':\n          this.setHomeMenu(!this.homeMenu);\n          break;\n        // DEBUG\n\n        case 'z':\n          if (!this.interactionMenu) {\n            this.setInteractionMenu(new _avo_interaction__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this));\n          }\n\n          break;\n        // DEBUG\n\n        case 'c':\n          if (((_this$hero = this.hero) === null || _this$hero === void 0 ? void 0 : _this$hero.spriteStyle) === 'toon') {\n            this.hero.spriteStyle = 'zelda';\n          } else if (((_this$hero2 = this.hero) === null || _this$hero2 === void 0 ? void 0 : _this$hero2.spriteStyle) === 'zelda') {\n            this.hero.spriteStyle = 'toon';\n          }\n\n          break;\n\n        case '-':\n        case '_':\n          this.camera.zoom = Math.max(0.5, this.camera.zoom - 0.5);\n          break;\n\n        case '+':\n        case '=':\n          this.camera.zoom = Math.min(4, this.camera.zoom + 0.5);\n          break;\n      } // General input\n\n\n      if (!this.playerInput.keysPressed[e.key]) {\n        this.playerInput.keysPressed[e.key] = {\n          duration: 0,\n          acknowledged: false\n        };\n      }\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(e) {\n      this.playerInput.keysPressed[e.key] = undefined;\n    }\n  }, {\n    key: \"buttonHome_onClick\",\n    value: function buttonHome_onClick() {\n      this.setHomeMenu(!this.homeMenu);\n    }\n  }, {\n    key: \"buttonFullscreen_onClick\",\n    value: function buttonFullscreen_onClick() {\n      var isFullscreen = document.fullscreenElement;\n\n      if (!isFullscreen) {\n        if (this.html.main.requestFullscreen) {\n          this.html.main.className = 'fullscreen';\n          this.html.main.requestFullscreen();\n        }\n      } else {\n        var _document$exitFullscr, _document;\n\n        (_document$exitFullscr = (_document = document).exitFullscreen) === null || _document$exitFullscr === void 0 ? void 0 : _document$exitFullscr.call(_document);\n        this.html.main.className = '';\n      }\n\n      this.updateUI();\n    }\n  }, {\n    key: \"buttonReload_onClick\",\n    value: function buttonReload_onClick() {\n      this.levels.reload();\n    } // CNY 2023\n\n  }, {\n    key: \"buttonArrowLeft_onDown\",\n    value: function buttonArrowLeft_onDown(e) {\n      this.playerInput.buttonArrowLeftPressed = true;\n      return stopEvent(e);\n    }\n  }, {\n    key: \"buttonArrowLeft_onUp\",\n    value: function buttonArrowLeft_onUp(e) {\n      this.playerInput.buttonArrowLeftPressed = false;\n      return stopEvent(e);\n    }\n  }, {\n    key: \"buttonArrowRight_onDown\",\n    value: function buttonArrowRight_onDown(e) {\n      this.playerInput.buttonArrowRightPressed = true;\n      return stopEvent(e);\n    }\n  }, {\n    key: \"buttonArrowRight_onUp\",\n    value: function buttonArrowRight_onUp(e) {\n      this.playerInput.buttonArrowRightPressed = false;\n      return stopEvent(e);\n    }\n    /*\r\n    Section: Gameplay\r\n    ----------------------------------------------------------------------------\r\n     */\n\n  }, {\n    key: \"addEntity\",\n    value: function addEntity(entity) {\n      if (!entity) return null;\n      if (!this.entities.includes(entity)) this.entities.push(entity);\n      return entity;\n    }\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity(entityOrMatchingFn) {\n      if (!entityOrMatchingFn) return;\n\n      if (typeof entityOrMatchingFn === 'function') {\n        this.entities.filter(entityOrMatchingFn).forEach(function (entity) {\n          entity._expired = true;\n        });\n      } else if (this.entities.includes(entityOrMatchingFn)) {\n        entityOrMatchingFn._expired = true;\n      }\n    }\n  }, {\n    key: \"addRule\",\n    value: function addRule(rule) {\n      if (!rule) return;\n      var id = rule._type;\n      this.rules[id] = rule;\n    }\n  }, {\n    key: \"clearRules\",\n    value: function clearRules() {\n      for (var id in this.rules) {\n        delete this.rules[id];\n      }\n    }\n    /*\r\n    Section: Painting\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Applies camera transforms to the canvas.\r\n    Should be run right before drawing an Entity (or etc) so the object is drawn\r\n    relative to the camera's view.\r\n     */\n\n  }, {\n    key: \"applyCameraTransforms\",\n    value: function applyCameraTransforms() {\n      if (this._canvasHasCameraTransforms) throw new Error('Canvas already has camera transforms.');\n      this._canvasHasCameraTransforms = true;\n      var c2d = this.canvas2d;\n      var camera = this.camera;\n      c2d.save();\n      c2d.translate(camera.x, camera.y);\n      c2d.scale(camera.zoom, camera.zoom);\n    }\n    /*\r\n    Removes camera transforms from the canvas.\r\n     */\n\n  }, {\n    key: \"undoCameraTransforms\",\n    value: function undoCameraTransforms() {\n      if (!this._canvasHasCameraTransforms) throw new Error('Canvas doesn\\'t have camera transforms.');\n      this._canvasHasCameraTransforms = false;\n      this.canvas2d.restore();\n    }\n    /*\r\n    Section: Misc\r\n    ----------------------------------------------------------------------------\r\n     */\n\n  }, {\n    key: \"checkCollisions\",\n    value: function checkCollisions(timeStep) {\n      for (var a = 0; a < this.entities.length; a++) {\n        var entityA = this.entities[a];\n\n        for (var b = a + 1; b < this.entities.length; b++) {\n          var entityB = this.entities[b];\n          var collisionCorrection = _avo_physics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkCollision(entityA, entityB);\n\n          if (collisionCorrection) {\n            entityA.onCollision(entityB, collisionCorrection.a);\n            entityB.onCollision(entityA, collisionCorrection.b);\n          }\n        }\n      }\n    }\n  }]);\n\n  return AvO;\n}();\n\n\n\nfunction getEventCoords(event, element) {\n  var xRatio = element.width && element.offsetWidth ? element.width / element.offsetWidth : 1;\n  var yRatio = element.height && element.offsetHeight ? element.height / element.offsetHeight : 1;\n  var x = event.offsetX * xRatio;\n  var y = event.offsetY * yRatio;\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction stopEvent(e) {\n  if (!e) return false;\n  e.preventDefault && e.preventDefault();\n  e.stopPropagation && e.stopPropagation();\n  e.returnValue = false;\n  e.cancelBubble = true;\n  return false;\n}\n\n//# sourceURL=webpack://cny2023/./src/avo/avo.js?");

/***/ }),

/***/ "./src/avo/constants.js":
/*!******************************!*\
  !*** ./src/avo/constants.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CNY2023_COLS\": () => (/* binding */ CNY2023_COLS),\n/* harmony export */   \"CNY2023_GRAVITY\": () => (/* binding */ CNY2023_GRAVITY),\n/* harmony export */   \"CNY2023_RABBIT_SPEED\": () => (/* binding */ CNY2023_RABBIT_SPEED),\n/* harmony export */   \"CNY2023_ROWS\": () => (/* binding */ CNY2023_ROWS),\n/* harmony export */   \"DIRECTIONS\": () => (/* binding */ DIRECTIONS),\n/* harmony export */   \"EXPECTED_FRAMES_PER_SECOND\": () => (/* binding */ EXPECTED_FRAMES_PER_SECOND),\n/* harmony export */   \"EXPECTED_TIMESTEP\": () => (/* binding */ EXPECTED_TIMESTEP),\n/* harmony export */   \"LAYERS\": () => (/* binding */ LAYERS),\n/* harmony export */   \"MAX_LAYER\": () => (/* binding */ MAX_LAYER),\n/* harmony export */   \"MIN_LAYER\": () => (/* binding */ MIN_LAYER),\n/* harmony export */   \"PLAYER_ACTIONS\": () => (/* binding */ PLAYER_ACTIONS),\n/* harmony export */   \"ROTATIONS\": () => (/* binding */ ROTATIONS),\n/* harmony export */   \"SHAPES\": () => (/* binding */ SHAPES),\n/* harmony export */   \"TILE_SIZE\": () => (/* binding */ TILE_SIZE)\n/* harmony export */ });\nvar TILE_SIZE = 32;\n/*\r\nEach Entity has a physical shape.\r\n */\n\nvar SHAPES = {\n  NONE: 'none',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  POLYGON: 'polygon'\n};\n/*\r\nEach Entity has a directional orientation, which can be interpreted as either\r\n\"rotation\" (if we want to know the precise angle for physics calculations) or\r\n\"direction\" (if we want to match it with up/down/left/right-facing sprites).\r\n */\n\nvar ROTATIONS = {\n  EAST: 0,\n  SOUTHEAST: Math.PI * 0.25,\n  SOUTH: Math.PI * 0.5,\n  SOUTHWEST: Math.PI * 0.75,\n  WEST: Math.PI,\n  NORTHWEST: Math.PI * -0.75,\n  NORTH: Math.PI * -0.5,\n  NORTHEAST: Math.PI * -0.25\n};\nvar DIRECTIONS = {\n  EAST: 0,\n  SOUTH: 1,\n  WEST: 2,\n  NORTH: 3\n};\nvar PLAYER_ACTIONS = {\n  IDLE: 'idle',\n  // Player isn't doing anything\n  POINTER_DOWN: 'pointer down' // Player is actively interacting with the canvas.\n\n};\n/*\r\nThe paint() step of the core engine, each Entity, and each Rule can paint\r\ninformation in different visual layers.\r\n */\n\nvar LAYERS = {\n  BACKGROUND: 0,\n  // Background layer, mostly for floors.\n  ENTITIES_LOWER: 1,\n  // Main object layer.\n  ENTITIES_UPPER: 2,\n  // Additional object layer (e.g. flying objects)\n  HUD: 3\n};\nvar MIN_LAYER = 0;\nvar MAX_LAYER = 3;\n/*\r\nWhile the engine is technically able to support any given framerate (determined\r\nby the hardware), a baseline is required to ground our video game logic to.\r\ne.g. we can say that we expect an object with \"movement speed\" of \"2\" to travel\r\n120 pixels in 1 second. (2 pixels per frame * 60 frames per second)\r\n */\n\nvar EXPECTED_FRAMES_PER_SECOND = 60;\nvar EXPECTED_TIMESTEP = 1000 / EXPECTED_FRAMES_PER_SECOND; // CNY2023\n\nvar CNY2023_COLS = 40;\nvar CNY2023_ROWS = 16;\nvar CNY2023_GRAVITY = 0.7;\nvar CNY2023_RABBIT_SPEED = 0.5;\n\n//# sourceURL=webpack://cny2023/./src/avo/constants.js?");

/***/ }),

/***/ "./src/avo/entity/entity.js":
/*!**********************************!*\
  !*** ./src/avo/entity/entity.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\nvar MOVE_MAX_SPEED_MODIFIER = 2 / _avo_constants__WEBPACK_IMPORTED_MODULE_0__.EXPECTED_TIMESTEP;\nvar PUSH_MAX_SPEED_MODIFIER = 60 / _avo_constants__WEBPACK_IMPORTED_MODULE_0__.EXPECTED_TIMESTEP;\nvar MOVE_ACCELERATION_MODIFIER = 1 / _avo_constants__WEBPACK_IMPORTED_MODULE_0__.EXPECTED_TIMESTEP;\nvar MOVE_DECELERATION_MODIFIER = 0.2 / _avo_constants__WEBPACK_IMPORTED_MODULE_0__.EXPECTED_TIMESTEP;\nvar PUSH_DECELERATION_MODIFIER = 0.2 / _avo_constants__WEBPACK_IMPORTED_MODULE_0__.EXPECTED_TIMESTEP;\nvar MASS_TO_LINEWIDTH_RATIO = 5;\n\nvar Entity = /*#__PURE__*/function () {\n  function Entity(app) {\n    _classCallCheck(this, Entity);\n\n    this._app = app;\n    this._type = 'entity';\n    this.name = ''; // Optional identifier\n    // General entity attributes\n\n    this.colour = '#ccc'; // Expired entities are removed at the end of the cycle.\n\n    this._expired = false; // Positional data\n\n    this.x = 0;\n    this.y = 0;\n    this.size = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n    this._rotation = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH; // Rotation in radians\n\n    this.shape = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE;\n    this.shapePolygonPath = null; // Only applicable if shape === SHAPES.POLYGON\n    // Physics (movement): self locomotion and external (pushed) movement.\n\n    this.moveX = 0;\n    this.moveY = 0;\n    this.pushX = 0;\n    this.pushY = 0; // Additional physics\n\n    this._solid = true;\n    this._movable = true;\n    this._mass = 10; // Only matters if solid && movable\n\n    this._moveAcceleration = this.size * MOVE_ACCELERATION_MODIFIER;\n    this._moveDeceleration = this.size * MOVE_DECELERATION_MODIFIER;\n    this._moveMaxSpeed = this.size * MOVE_MAX_SPEED_MODIFIER;\n    this._pushDeceleration = this.size * PUSH_DECELERATION_MODIFIER;\n    this._pushMaxSpeed = this.size * PUSH_MAX_SPEED_MODIFIER; // Additional animation\n\n    this._spriteDirectionEW = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST; // Only used for 2-directional toon-style sprites\n\n    this._spriteDirectionNS = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH;\n  }\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n\n\n  _createClass(Entity, [{\n    key: \"play\",\n    value: function play(timeStep) {\n      // Upkeep: limit speed\n      this.doMaxSpeedLimit(timeStep); // Update position\n\n      var timeCorrection = 1; // const timeCorrection = (timeStep / EXPECTED_TIMESTEP)  // Edit: time correction may not be needed since Entities fix their own moveXY/pushXY values\n\n      this.x += (this.moveX + this.pushX) * timeCorrection;\n      this.y += (this.moveY + this.pushY) * timeCorrection; // Upkeep: deceleration\n\n      this.doMoveDeceleration(timeStep);\n      this.doPushDeceleration(timeStep);\n    }\n    /*\r\n    Paint entity's hitbox.\r\n     */\n\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var c2d = this._app.canvas2d;\n      var camera = this._app.camera;\n\n      this._app.applyCameraTransforms();\n\n      if (layer === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.LAYERS.ENTITIES_LOWER) {\n        c2d.fillStyle = this.colour;\n        c2d.strokeStyle = '#444';\n        c2d.lineWidth = this.mass / MASS_TO_LINEWIDTH_RATIO; // Draw shape outline\n\n        switch (this.shape) {\n          case _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE:\n            c2d.beginPath();\n            c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI);\n            c2d.closePath();\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n\n          case _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE:\n            c2d.beginPath();\n            c2d.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);\n            c2d.closePath();\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n\n          case _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON:\n            c2d.beginPath();\n            var coords = this.vertices;\n            if (coords.length >= 1) c2d.moveTo(coords[coords.length - 1].x, coords[coords.length - 1].y);\n\n            for (var i = 0; i < coords.length; i++) {\n              c2d.lineTo(coords[i].x, coords[i].y);\n            }\n\n            c2d.closePath();\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n        } // Draw anchor point, mostly for debugging\n\n\n        c2d.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        c2d.beginPath();\n        c2d.arc(this.x, this.y, 2, 0, 2 * Math.PI); // Anchor point\n\n        if (this.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n          // Direction line\n          c2d.moveTo(this.x + this.size * 0.1 * Math.cos(this.rotation), this.y + this.size * 0.1 * Math.sin(this.rotation));\n          c2d.lineTo(this.x + this.size * 0.5 * Math.cos(this.rotation), this.y + this.size * 0.5 * Math.sin(this.rotation));\n        }\n\n        c2d.stroke();\n        c2d.closePath();\n      }\n\n      this._app.undoCameraTransforms();\n    }\n    /*\r\n    Section: Game Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Applies an effect to this entity. Usually called by another antity.\r\n    e.g. a fireball hits this character and applies an \"ON FIRE\" effect.\r\n     */\n\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, source) {}\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Triggers when this entity hits/touches/intersects with another.\r\n     */\n\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      this.doBounce(target, collisionCorrection);\n      this.x = collisionCorrection.x;\n      this.y = collisionCorrection.y;\n    }\n    /*\r\n    Section: Physics\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    By default, every moving entity decelerates (because we don't exist in a\r\n    perfect vacuum and the game doesn't take place on a slippery ice).\r\n    Entities can intentionally override this logic,\r\n    e.g. \"if a hero is walking, ignore deceleration.\"\r\n     */\n\n  }, {\n    key: \"doMoveDeceleration\",\n    value: function doMoveDeceleration(timeStep) {\n      var moveDeceleration = this.moveDeceleration * timeStep / _avo_constants__WEBPACK_IMPORTED_MODULE_0__.EXPECTED_TIMESTEP || 0;\n      var curRotation = Math.atan2(this.moveY, this.moveX);\n      var newMoveSpeed = Math.max(0, this.moveSpeed - moveDeceleration);\n      this.moveX = newMoveSpeed * Math.cos(curRotation);\n      this.moveY = newMoveSpeed * Math.sin(curRotation);\n    }\n  }, {\n    key: \"doPushDeceleration\",\n    value: function doPushDeceleration(timeStep) {\n      var pushDeceleration = this.pushDeceleration * timeStep / _avo_constants__WEBPACK_IMPORTED_MODULE_0__.EXPECTED_TIMESTEP || 0;\n      var curRotation = Math.atan2(this.pushY, this.pushX);\n      var newPushSpeed = Math.max(0, this.pushSpeed - pushDeceleration);\n      this.pushX = newPushSpeed * Math.cos(curRotation);\n      this.pushY = newPushSpeed * Math.sin(curRotation);\n    }\n    /*\r\n    Every entity has a maximum speed limit. Intentional movement speed and\r\n    external force movement speed are treated separately.\r\n     */\n\n  }, {\n    key: \"doMaxSpeedLimit\",\n    value: function doMaxSpeedLimit(timeStep) {\n      // Limit max move speed\n      if (this.moveMaxSpeed >= 0) {\n        var correctedSpeed = Math.min(this.moveMaxSpeed, this.moveSpeed);\n        var moveAngle = this.moveAngle;\n        this.moveX = correctedSpeed * Math.cos(moveAngle);\n        this.moveY = correctedSpeed * Math.sin(moveAngle);\n      } // Limit max push speed\n\n\n      if (this.pushMaxSpeed >= 0) {\n        var _correctedSpeed = Math.min(this.pushMaxSpeed, this.pushSpeed);\n\n        var pushAngle = this.pushAngle;\n        this.pushX = _correctedSpeed * Math.cos(pushAngle);\n        this.pushY = _correctedSpeed * Math.sin(pushAngle);\n      }\n    }\n    /*\r\n    When a solid pushed entity hits another solid entity, momentum is transferred.\r\n    Usually, this leads to elastic collisions, because that chaos is fun!\r\n     */\n\n  }, {\n    key: \"doBounce\",\n    value: function doBounce(target, collisionCorrection) {\n      // If this object isn't a movable solid, it can't bounce.\n      if (!(this.movable && this.solid)) return;\n\n      if ( // this object is bouncing off an unmovable object\n      this.movable && this.solid && !target.movable && target.solid) {\n        if (this.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && target.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n          // For circle + circle collisions, the collision correction already\n          // tells us the bounce direction.\n          var angle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var speed = Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n          this.pushX = Math.cos(angle) * speed;\n          this.pushY = Math.sin(angle) * speed;\n        } else if (this.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && (target.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || target.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n          // For circle + polygon collisions, we need to know...\n          // - the original angle this circle was moving towards (or rather, its\n          //   reverse, because we want a bounce)\n          // - the normal vector (of the edge) of the polygon this circle collided\n          //   into (which we can get from the collision correction)\n          // - the angle between them\n          var reverseOriginalAngle = Math.atan2(-this.pushY, -this.pushX);\n          var normalAngle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var angleBetween = normalAngle - reverseOriginalAngle;\n\n          var _angle = reverseOriginalAngle + 2 * angleBetween;\n\n          var _speed = Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n\n          this.pushX = Math.cos(_angle) * _speed;\n          this.pushY = Math.sin(_angle) * _speed;\n        } else {// For the moment, we're not too concerned about polygons bumping into each other\n        }\n      } else if ( // this object is bouncing off another movable object\n      target.movable && target.solid && collisionCorrection.pushX !== undefined && collisionCorrection.pushY !== undefined) {\n        this.pushX = collisionCorrection.pushX;\n        this.pushY = collisionCorrection.pushY;\n      }\n    }\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    NOTE: An Entity can support two styles of sprite sheets:\r\n    1. 4-directional (Zelda-style) sprite sheets, which have sprites facing N, S,\r\n       E, and W for each \"action\"/\"state\".\r\n    2. 2-directional (Toon-style) sprite sheets, which have sprites facing SE and\r\n       NE for each \"action\"/\"state\", which are then mirrored if the entity is\r\n       facing W.\r\n     */\n\n    /*\r\n    Get the directional orientation of the sprite, for a 4-directional\r\n    (Zelda-style) sprite sheet.\r\n     */\n\n  }, {\n    key: \"getSpriteDirection\",\n    value: function getSpriteDirection() {\n      //Favour East and West when rotation is exactly SW, NW, SE or NE.\n      if (this._rotation <= Math.PI * 0.25 && this._rotation >= Math.PI * -0.25) {\n        return _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST;\n      } else if (this._rotation > Math.PI * 0.25 && this._rotation < Math.PI * 0.75) {\n        return _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH;\n      } else if (this._rotation < Math.PI * -0.25 && this._rotation > Math.PI * -0.75) {\n        return _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH;\n      } else {\n        return _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST;\n      }\n    }\n    /*\r\n    Get the directional orientation of the sprite, for a 2-directional\r\n    (Toon-style) sprite sheet.\r\n     */\n\n  }, {\n    key: \"getSpriteDirectionEW\",\n    value: function getSpriteDirectionEW() {\n      return this._spriteDirectionEW;\n    }\n  }, {\n    key: \"getSpriteDirectionNS\",\n    value: function getSpriteDirectionNS() {\n      return this._spriteDirectionNS;\n    }\n    /*\r\n    Get the column/row of the current sprite on the sprite sheet.\r\n     */\n\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      return 0;\n    }\n    /*\r\n    Section: Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.size / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.size / 2;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y - this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val + this.size / 2;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val - this.size / 2;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this.size / 2;\n    },\n    set: function set(val) {\n      this.size = val * 2;\n    }\n    /*\r\n    Rotation tracks the precise angle the entity is facing, in radians, clockwise\r\n    positive. 0° (0 rad) is east/right-facing, 90° (+pi/4 rad) is\r\n    south/down-facing.\r\n     */\n\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(val) {\n      this._rotation = val;\n\n      while (this._rotation > Math.PI) {\n        this._rotation -= Math.PI * 2;\n      }\n\n      while (this._rotation <= -Math.PI) {\n        this._rotation += Math.PI * 2;\n      } // Keep track of sprite direction for 2-directional toon-type sprites\n\n\n      if (this._rotation < 0) {\n        this._spriteDirectionNS = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH;\n      } else if (this._rotation >= 0) {\n        // Favour south-facing\n        this._spriteDirectionNS = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH;\n      }\n\n      var absRotation = Math.abs(this._rotation);\n\n      if (absRotation < Math.PI * 0.5) {\n        this._spriteDirectionEW = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST;\n      } else if (absRotation > Math.PI * 0.5) {\n        this._spriteDirectionEW = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST;\n      }\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      var _this = this;\n\n      var v = [];\n\n      if (this.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE) {\n        v.push({\n          x: this.left,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.bottom\n        });\n        v.push({\n          x: this.left,\n          y: this.bottom\n        });\n      } else if (this.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        //Approximation\n        CIRCLE_TO_POLYGON_APPROXIMATOR.map(function (approximator) {\n          v.push({\n            x: _this.x + _this.radius * approximator.cosAngle,\n            y: _this.y + _this.radius * approximator.sinAngle\n          });\n        });\n      } else if (this.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) {\n        if (!this.shapePolygonPath) return [];\n\n        for (var i = 0; i < this.shapePolygonPath.length; i += 2) {\n          v.push({\n            x: this.x + this.shapePolygonPath[i],\n            y: this.y + this.shapePolygonPath[i + 1]\n          });\n        }\n      }\n\n      return v;\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.vertices is read only');\n    }\n  }, {\n    key: \"solid\",\n    get: function get() {\n      return this._solid;\n    },\n    set: function set(val) {\n      this._solid = val;\n    }\n  }, {\n    key: \"movable\",\n    get: function get() {\n      return this._movable;\n    },\n    set: function set(val) {\n      this._movable = val;\n    }\n  }, {\n    key: \"mass\",\n    get: function get() {\n      return this._mass;\n    },\n    set: function set(val) {\n      this._mass = val;\n    }\n  }, {\n    key: \"moveAcceleration\",\n    get: function get() {\n      return this._moveAcceleration;\n    },\n    set: function set(val) {\n      this._moveAcceleration = val;\n    }\n  }, {\n    key: \"moveDeceleration\",\n    get: function get() {\n      return this._moveDeceleration;\n    },\n    set: function set(val) {\n      this._moveDeceleration = val;\n    }\n  }, {\n    key: \"moveMaxSpeed\",\n    get: function get() {\n      return this._moveMaxSpeed;\n    },\n    set: function set(val) {\n      this._moveMaxSpeed = val;\n    }\n  }, {\n    key: \"pushDeceleration\",\n    get: function get() {\n      return this._pushDeceleration;\n    },\n    set: function set(val) {\n      this._pushDeceleration = val;\n    }\n  }, {\n    key: \"pushMaxSpeed\",\n    get: function get() {\n      return this._pushMaxSpeed;\n    },\n    set: function set(val) {\n      this._pushMaxSpeed = val;\n    }\n  }, {\n    key: \"moveSpeed\",\n    get: function get() {\n      return Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.moveSpeed is read only');\n    }\n  }, {\n    key: \"moveAngle\",\n    get: function get() {\n      return Math.atan2(this.moveY, this.moveX);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.moveAngle is read only');\n    }\n  }, {\n    key: \"pushSpeed\",\n    get: function get() {\n      return Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.pushSpeed is read only');\n    }\n  }, {\n    key: \"pushAngle\",\n    get: function get() {\n      return Math.atan2(this.pushY, this.pushX);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.pushAngle is read only');\n    }\n  }]);\n\n  return Entity;\n}();\n\n\nvar CIRCLE_TO_POLYGON_APPROXIMATOR = [_avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.EAST, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTHEAST, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTHWEST, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.WEST, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTHWEST, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTH, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTHEAST].map(function (angle) {\n  return {\n    cosAngle: Math.cos(angle),\n    sinAngle: Math.sin(angle)\n  };\n});\n\n//# sourceURL=webpack://cny2023/./src/avo/entity/entity.js?");

/***/ }),

/***/ "./src/avo/entity/index.js":
/*!*********************************!*\
  !*** ./src/avo/entity/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity */ \"./src/avo/entity/entity.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2023/./src/avo/entity/index.js?");

/***/ }),

/***/ "./src/avo/entity/types/cny2023/boost-pad.js":
/*!***************************************************!*\
  !*** ./src/avo/entity/types/cny2023/boost-pad.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BoostPad)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar DEFAULT_BOOST_POWER = 32;\n\nvar BoostPad = /*#__PURE__*/function (_Entity) {\n  _inherits(BoostPad, _Entity);\n\n  var _super = _createSuper(BoostPad);\n\n  function BoostPad(app) {\n    var _this;\n\n    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    var boostPower = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DEFAULT_BOOST_POWER;\n\n    _classCallCheck(this, BoostPad);\n\n    _this = _super.call(this, app);\n    _this._type = 'boost-pad';\n    _this.colour = '#c0a040';\n    _this.solid = false;\n    _this.movable = false;\n    _this.x = x;\n    _this.y = y;\n    _this.width = width;\n    _this.height = height;\n    _this.shape = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLYGON;\n    _this.shapePolygonPath = [];\n\n    _this.shapePolygonPath.push(width * -0.5, height * 0.5);\n\n    _this.shapePolygonPath.push(width * 0.5, height * 0.5);\n\n    _this.shapePolygonPath.push(width * 0.5, height * -0.5);\n\n    _this.shapePolygonPath.push(width * -0.5, height * -0.5);\n\n    _this.boostPower = boostPower;\n    return _this;\n  }\n\n  _createClass(BoostPad, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // super.paint(layer)\n      var app = this._app;\n      var c2d = this._app.canvas2d;\n      app.applyCameraTransforms();\n\n      if (layer === _avo_constants__WEBPACK_IMPORTED_MODULE_1__.LAYERS.ENTITIES_UPPER) {\n        var gradient = c2d.createLinearGradient(0, this.y - this.height / 2, 0, this.y + this.height / 2);\n        gradient.addColorStop(0, '#e0e0e0');\n        gradient.addColorStop(1, '#8080a0');\n        c2d.fillStyle = gradient; //c2d.fillStyle = '#e0e0e0'\n        //c2d.beginPath()\n        // Central \"puff\"\n\n        this.paint_circle(0, this.height * 1.2); // Programmatically fill up the central \"puffs\"\n\n        var distanceBetweenSteps = this.height / 2;\n        var maxSteps = this.width / 2 / distanceBetweenSteps;\n\n        for (var step = 1; step < maxSteps; step++) {\n          var size = this.height * ((maxSteps - step) / maxSteps * 0.6 + 0.6);\n          var offsetX = step * distanceBetweenSteps;\n          this.paint_circle(offsetX, size);\n          this.paint_circle(-offsetX, size);\n        } // Edge \"puffs\"\n\n\n        this.paint_circle(-this.width / 2, this.height * 0.5);\n        this.paint_circle(this.width / 2, this.height * 0.5); // Complete!\n        // c2d.closePath()\n        // c2d.fill()\n      }\n\n      app.undoCameraTransforms();\n    }\n  }, {\n    key: \"paint_circle\",\n    value: function paint_circle() {\n      var offsetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.height;\n      var c2d = this._app.canvas2d;\n      var offsetY = size > this.height ? 0 : (this.height - size) / 2;\n      c2d.beginPath();\n      c2d.arc(this.x + offsetX, this.y + offsetY, size / 2, 0, 2 * Math.PI);\n      c2d.closePath();\n      c2d.fill();\n    }\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _get(_getPrototypeOf(BoostPad.prototype), \"onCollision\", this).call(this, target, collisionCorrection);\n\n      var app = this._app;\n      var hero = app.hero;\n\n      if (target === hero) {\n        target.pushY = -this.boostPower; // this._expired = true  // Add this to crank up the difficulty\n      }\n    }\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.width / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.width / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.width / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.width / 2;\n    }\n  }]);\n\n  return BoostPad;\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/entity/types/cny2023/boost-pad.js?");

/***/ }),

/***/ "./src/avo/entity/types/cny2023/coin.js":
/*!**********************************************!*\
  !*** ./src/avo/entity/types/cny2023/coin.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Coin)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_misc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/misc */ \"./src/avo/misc.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar DECAY_MAX = 200;\nvar SPIN_MAX = 1000;\n/*\r\nCoins, when picked up by the Cat, increase the player's score.\r\n */\n\nvar Coin = /*#__PURE__*/function (_Entity) {\n  _inherits(Coin, _Entity);\n\n  var _super = _createSuper(Coin);\n\n  function Coin(app) {\n    var _this;\n\n    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Coin);\n\n    _this = _super.call(this, app);\n    _this._type = 'cny2023-coin';\n    _this.size = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    _this.colour = 'rgba(128, 92, 0, 0.5)';\n    _this.x = x;\n    _this.y = y;\n    _this.solid = false;\n    _this.movable = false;\n    _this.spinCounter = 0;\n    _this.pickedUp = false;\n    _this.decayCounter = 0;\n    return _this;\n  }\n\n  _createClass(Coin, [{\n    key: \"play\",\n    value: function play(timeStep) {\n      _get(_getPrototypeOf(Coin.prototype), \"play\", this).call(this, timeStep);\n\n      if (!this.pickedUp) {\n        // If the coin hasn't been picked up, animate the spin!\n        this.spinCounter = (this.spinCounter + timeStep) % SPIN_MAX;\n      } else {\n        // If the coin is picked up, begin the decay process\n        this.decayCounter = Math.min(this.decayCounter + timeStep, DECAY_MAX);\n        if (this.decayCounter >= DECAY_MAX) this._expired = true;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      var c2d = app.canvas2d;\n      var animationSpriteSheet = app.assets['sprites'];\n      if (!animationSpriteSheet) return;\n      app.applyCameraTransforms();\n      var FLIP_SPRITE = 1;\n      var SPRITE_SCALE = 2;\n      var SPRITE_SIZE = 16; // Draw the sprite\n\n      if (layer === _avo_constants__WEBPACK_IMPORTED_MODULE_1__.LAYERS.ENTITIES_LOWER) {\n        var srcX = this.getSpriteCol() * SPRITE_SIZE;\n        var srcY = this.getSpriteRow() * SPRITE_SIZE;\n        var sizeX = SPRITE_SIZE;\n        var sizeY = SPRITE_SIZE;\n        c2d.translate(this.x, this.y); // 1. This moves the 'drawing origin' to match the position of (the centre of) the Entity.\n\n        c2d.scale(SPRITE_SCALE * FLIP_SPRITE, SPRITE_SCALE); // 2. This ensures the sprite scales with the 'drawing origin' as the anchor point.\n        // c2d.rotate(this.rotation)  // 3. If we wanted to, we could rotate the sprite around the 'drawing origin'.\n        // 4. tgtX and tgtY specify where to draw the sprite, relative to the 'drawing origin'.\n\n        var tgtX = -sizeX / 2; // Align centre of sprite to origin\n\n        var tgtY = -sizeY / 2; // Align centre sprite to origin\n\n        c2d.drawImage(animationSpriteSheet.img, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      }\n\n      this._app.undoCameraTransforms();\n      /*\r\n      const c2d = this._app.canvas2d\r\n      const camera = this._app.camera\r\n      const animationSpritesheet = this._app.assets.cny2023\r\n        if (layer === 1) {\r\n        if (!animationSpritesheet) return\r\n          const SPRITE_SIZE = 96\r\n        let SPRITE_OFFSET_X = 0\r\n        let SPRITE_OFFSET_Y = 0\r\n          const srcSizeX = SPRITE_SIZE\r\n        const srcSizeY = SPRITE_SIZE\r\n        let srcX = SPRITE_SIZE * 2\r\n        let srcY = 0\r\n          const tgtSizeX = SPRITE_SIZE * 1\r\n        const tgtSizeY = SPRITE_SIZE * 1\r\n        const tgtX = Math.floor(this.x + camera.x) - srcSizeX / 2 + SPRITE_OFFSET_X - (tgtSizeX - srcSizeX) / 2\r\n        const tgtY = Math.floor(this.y + camera.y) - srcSizeY / 2 + SPRITE_OFFSET_Y - (tgtSizeY - srcSizeY) / 2\r\n          const progress = (!this.pickedUp)\r\n          ? this.spinCounter / SPIN_MAX\r\n          : this.decayCounter / DECAY_MAX\r\n          if (!this.pickedUp) {\r\n          if (progress < 0.25) srcY = SPRITE_SIZE * 0\r\n          else if (progress < 0.5) srcY = SPRITE_SIZE * 1\r\n          else if (progress < 0.75) srcY = SPRITE_SIZE * 2\r\n          else srcY = SPRITE_SIZE * 3\r\n        } else {\r\n          srcX = SPRITE_SIZE * 3\r\n          if (progress < 0.33) srcY = SPRITE_SIZE * 0\r\n          else if (progress < 0.33) srcY = SPRITE_SIZE * 1\r\n          else srcY = SPRITE_SIZE * 2\r\n        }\r\n          c2d.drawImage(animationSpritesheet.img, Math.floor(srcX), Math.floor(srcY), Math.floor(srcSizeX), Math.floor(srcSizeY), Math.floor(tgtX), Math.floor(tgtY), Math.floor(tgtSizeX), Math.floor(tgtSizeY))\r\n      }\r\n      */\n\n    }\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _get(_getPrototypeOf(Coin.prototype), \"onCollision\", this).call(this, target, collisionCorrection);\n\n      if (this.pickedUp) return;\n      var app = this._app;\n      var hero = app.hero;\n      var goals = app.rules['cny2023-goals'];\n      if (!hero || !goals) return;\n\n      if (target === hero) {\n        this.pickedUp = true;\n        goals.increaseScore();\n      }\n    }\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return !this.pickedUp ? 2 : 3;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      var progress = !this.pickedUp ? this.spinCounter / SPIN_MAX : this.decayCounter / DECAY_MAX;\n      if (progress < 0.25) return 0;else if (progress < 0.5) return 1;else if (progress < 0.75) return 2;else return 3;\n    }\n  }]);\n\n  return Coin;\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/entity/types/cny2023/coin.js?");

/***/ }),

/***/ "./src/avo/entity/types/cny2023/ground.js":
/*!************************************************!*\
  !*** ./src/avo/entity/types/cny2023/ground.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Ground)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Ground = /*#__PURE__*/function (_Entity) {\n  _inherits(Ground, _Entity);\n\n  var _super = _createSuper(Ground);\n\n  function Ground(app) {\n    var _this;\n\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var cutCorner = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, Ground);\n\n    _this = _super.call(this, app);\n    _this._type = 'wall';\n    _this.colour = '#60a080';\n    _this.solid = true;\n    _this.movable = false;\n    _this.x = col * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    _this.y = row * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    _this.shape = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLYGON;\n    _this.shapePolygonPath = [];\n    if (cutCorner !== 'nw') _this.shapePolygonPath.push(0, 0);\n    if (cutCorner !== 'ne') _this.shapePolygonPath.push(width * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE, 0);\n    if (cutCorner !== 'se') _this.shapePolygonPath.push(width * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE, height * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE);\n    if (cutCorner !== 'sw') _this.shapePolygonPath.push(0, height * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE);\n    return _this;\n  }\n\n  _createClass(Ground, [{\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _get(_getPrototypeOf(Ground.prototype), \"onCollision\", this).call(this, target, collisionCorrection);\n\n      var app = this._app;\n      var controls = app.rules['cny2023-controls'];\n      var goals = app.rules['cny2023-goals'];\n      if (!controls || !goals) return;\n      if (target === app.hero) goals.triggerLoseScreen();\n    }\n  }]);\n\n  return Ground;\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/entity/types/cny2023/ground.js?");

/***/ }),

/***/ "./src/avo/entity/types/cny2023/moon.js":
/*!**********************************************!*\
  !*** ./src/avo/entity/types/cny2023/moon.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Moon)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Moon = /*#__PURE__*/function (_Entity) {\n  _inherits(Moon, _Entity);\n\n  var _super = _createSuper(Moon);\n\n  function Moon(app) {\n    var _this;\n\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Moon);\n\n    _this = _super.call(this, app);\n    _this._type = 'moon';\n    _this.colour = '#e0e0c0';\n    _this.solid = false;\n    _this.movable = false;\n    _this.size = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 8;\n    _this.pushMaxSpeed = 0;\n    _this.x = col * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    return _this;\n  }\n\n  _createClass(Moon, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      var c2d = app.canvas2d;\n      app.applyCameraTransforms();\n\n      if (layer === _avo_constants__WEBPACK_IMPORTED_MODULE_1__.LAYERS.ENTITIES_LOWER) {\n        var gradient = c2d.createLinearGradient(0, this.top, 0, this.bottom);\n        gradient.addColorStop(0, '#e0e0c0');\n        gradient.addColorStop(1, '#a0a090');\n        c2d.fillStyle = gradient;\n        c2d.beginPath();\n        c2d.arc(this.x, this.y, this.size * 0.5, 0, 2 * Math.PI);\n        c2d.closePath();\n        c2d.fill();\n      }\n\n      app.undoCameraTransforms();\n    }\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _get(_getPrototypeOf(Moon.prototype), \"onCollision\", this).call(this, target, collisionCorrection);\n\n      var app = this._app;\n      var hero = app.hero;\n      var goals = app.rules['cny2023-goals'];\n      if (!hero || !goals) return;\n      if (target === hero) goals.triggerWinScreen();\n    }\n  }]);\n\n  return Moon;\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/entity/types/cny2023/moon.js?");

/***/ }),

/***/ "./src/avo/entity/types/cny2023/rabbit.js":
/*!************************************************!*\
  !*** ./src/avo/entity/types/cny2023/rabbit.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rabbit)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Rabbit = /*#__PURE__*/function (_Entity) {\n  _inherits(Rabbit, _Entity);\n\n  var _super = _createSuper(Rabbit);\n\n  function Rabbit(app) {\n    var _this;\n\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Rabbit);\n\n    _this = _super.call(this, app);\n    _this._type = 'rabbit';\n    _this.colour = '#c06060';\n    _this.x = col * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    return _this;\n  }\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n\n\n  _createClass(Rabbit, [{\n    key: \"play\",\n    value: function play(timeStep) {\n      var app = this._app;\n\n      _get(_getPrototypeOf(Rabbit.prototype), \"play\", this).call(this, timeStep);\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      var c2d = app.canvas2d;\n      var animationSpriteSheet = app.assets['sprites'];\n      if (!animationSpriteSheet) return;\n      app.applyCameraTransforms();\n      var FLIP_SPRITE = this.direction === _avo_constants__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.WEST ? -1 : 1;\n      var SPRITE_SCALE = 3;\n      var SPRITE_SIZE = 32; // Draw the sprite\n\n      if (layer === _avo_constants__WEBPACK_IMPORTED_MODULE_1__.LAYERS.ENTITIES_UPPER) {\n        var srcX = this.getSpriteCol() * SPRITE_SIZE;\n        var srcY = this.getSpriteRow() * SPRITE_SIZE;\n        var sizeX = SPRITE_SIZE;\n        var sizeY = SPRITE_SIZE;\n        c2d.translate(this.x, this.y); // 1. This moves the 'drawing origin' to match the position of (the centre of) the Entity.\n\n        c2d.scale(SPRITE_SCALE * FLIP_SPRITE, SPRITE_SCALE); // 2. This ensures the sprite scales with the 'drawing origin' as the anchor point.\n        // c2d.rotate(this.rotation)  // 3. If we wanted to, we could rotate the sprite around the 'drawing origin'.\n        // 4. tgtX and tgtY specify where to draw the sprite, relative to the 'drawing origin'.\n\n        var tgtX = -sizeX / 2; // Align centre of sprite to origin\n\n        var tgtY = -sizeY / 2; // Align centre sprite to origin\n\n        c2d.drawImage(animationSpriteSheet.img, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      }\n\n      this._app.undoCameraTransforms();\n    }\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      return this.pushY < 0 ? 0 : 1;\n    }\n  }]);\n\n  return Rabbit;\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/entity/types/cny2023/rabbit.js?");

/***/ }),

/***/ "./src/avo/image-asset.js":
/*!********************************!*\
  !*** ./src/avo/image-asset.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ImageAsset)\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ImageAsset = /*#__PURE__*/_createClass(function ImageAsset(url) {\n  _classCallCheck(this, ImageAsset);\n\n  this.url = url;\n  this.ready = false;\n  this.error = false;\n  this.img = new Image();\n\n  this.img.onload = function () {\n    this.ready = true;\n    this.error = false;\n  }.bind(this);\n\n  this.img.onerror = function (err) {\n    console.error('ImageAsset Error (' + this.url + '): ', err);\n    this.ready = false;\n    this.error = true;\n  }.bind(this);\n\n  this.img.src = this.url;\n});\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/image-asset.js?");

/***/ }),

/***/ "./src/avo/index.js":
/*!**************************!*\
  !*** ./src/avo/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _avo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo */ \"./src/avo/avo.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_avo__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2023/./src/avo/index.js?");

/***/ }),

/***/ "./src/avo/interaction/index.js":
/*!**************************************!*\
  !*** ./src/avo/interaction/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _interaction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction */ \"./src/avo/interaction/interaction.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_interaction__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2023/./src/avo/interaction/index.js?");

/***/ }),

/***/ "./src/avo/interaction/interaction.js":
/*!********************************************!*\
  !*** ./src/avo/interaction/interaction.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interaction)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(app) {\n    _classCallCheck(this, Interaction);\n\n    this._app = app;\n    this._type = 'interaction';\n    this.name = ''; // Optional identifier\n  }\n\n  _createClass(Interaction, [{\n    key: \"load\",\n    value: function load(div) {\n      var _this = this;\n\n      var menu = document.createElement('div');\n      menu.innerHTML = \"\\n      <h3>Example Interaction Menu</h3>\\n    \";\n      var closeButton = document.createElement('button');\n      closeButton.type = 'button';\n      closeButton.innerText = 'OK!';\n\n      closeButton.onclick = function () {\n        _this._app.setInteractionMenu(false);\n      };\n\n      menu.appendChild(closeButton);\n      div.appendChild(menu);\n      setTimeout(function () {\n        closeButton.focus();\n      }, 100);\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {}\n  }]);\n\n  return Interaction;\n}();\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/interaction/interaction.js?");

/***/ }),

/***/ "./src/avo/json-asset.js":
/*!*******************************!*\
  !*** ./src/avo/json-asset.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JsonAsset)\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JsonAsset = /*#__PURE__*/_createClass(function JsonAsset(url) {\n  _classCallCheck(this, JsonAsset);\n\n  this.url = url;\n  this.ready = false;\n  this.error = false;\n  this.data = null;\n  fetch(this.url).then(function (response) {\n    if (!response || !response.ok) throw new Error('Invalid response');\n    return response.json();\n  }.bind(this)).then(function (data) {\n    if (!data) throw new Error('Invalid response');\n    this.data = data;\n    this.ready = true;\n    this.error = false;\n  }.bind(this))[\"catch\"](function (err) {\n    console.error('JsonAsset Error (' + this.url + '): ', err);\n    this.data = null;\n    this.ready = false;\n    this.error = true;\n  }.bind(this));\n});\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/json-asset.js?");

/***/ }),

/***/ "./src/avo/levels.js":
/*!***************************!*\
  !*** ./src/avo/levels.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CNY2023_CEILING_ROW\": () => (/* binding */ CNY2023_CEILING_ROW),\n/* harmony export */   \"CNY2023_CEILING_Y\": () => (/* binding */ CNY2023_CEILING_Y),\n/* harmony export */   \"CNY2023_FLOOR_Y\": () => (/* binding */ CNY2023_FLOOR_Y),\n/* harmony export */   \"default\": () => (/* binding */ Levels)\n/* harmony export */ });\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_types_cny2023_rabbit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/types/cny2023/rabbit */ \"./src/avo/entity/types/cny2023/rabbit.js\");\n/* harmony import */ var _avo_entity_types_cny2023_moon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/entity/types/cny2023/moon */ \"./src/avo/entity/types/cny2023/moon.js\");\n/* harmony import */ var _avo_entity_types_cny2023_ground__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/entity/types/cny2023/ground */ \"./src/avo/entity/types/cny2023/ground.js\");\n/* harmony import */ var _avo_entity_types_cny2023_boost_pad__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @avo/entity/types/cny2023/boost-pad */ \"./src/avo/entity/types/cny2023/boost-pad.js\");\n/* harmony import */ var _avo_entity_types_cny2023_coin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @avo/entity/types/cny2023/coin */ \"./src/avo/entity/types/cny2023/coin.js\");\n/* harmony import */ var _avo_rule_types_cny2023_controls__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @avo/rule/types/cny2023-controls */ \"./src/avo/rule/types/cny2023-controls.js\");\n/* harmony import */ var _avo_rule_types_cny2023_goals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @avo/rule/types/cny2023-goals */ \"./src/avo/rule/types/cny2023-goals.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\n\n\n\n\nvar MIN_X = 0;\nvar MAX_X = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_COLS * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\nvar MID_X = (MAX_X + MIN_X) / 2;\nvar ROWS_BETWEEN_BOOSTSPADS = 8;\nvar FIRST_BOOST_PAD_WIDTH = 8 * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\nvar CNY2023_CEILING_ROW = -100;\nvar CNY2023_CEILING_Y = CNY2023_CEILING_ROW * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\nvar CNY2023_FLOOR_Y = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_ROWS * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n\nvar Levels = /*#__PURE__*/function () {\n  function Levels(app) {\n    _classCallCheck(this, Levels);\n\n    this._app = app;\n    this.current = 0;\n    this.firstBoostPad = undefined; // CNY2023\n  }\n\n  _createClass(Levels, [{\n    key: \"reset\",\n    value: function reset() {\n      var app = this._app;\n      app.hero = undefined;\n      app.entities = [];\n      app.clearRules();\n      app.camera.target = null;\n      app.camera.x = 0;\n      app.camera.y = 0;\n      app.camera.zoom = 1;\n      app.playerAction = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.PLAYER_ACTIONS.IDLE;\n      app.setInteractionMenu(false);\n      this.firstBoostPad = undefined;\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      this.current = level;\n      this.reset();\n      this.generate_default();\n    }\n  }, {\n    key: \"reload\",\n    value: function reload() {\n      this.load(this.current);\n    }\n    /*\r\n    Default level.\r\n     */\n\n  }, {\n    key: \"generate_default\",\n    value: function generate_default() {\n      var app = this._app;\n      app.addRule(new _avo_rule_types_cny2023_controls__WEBPACK_IMPORTED_MODULE_6__[\"default\"](app));\n      app.addRule(new _avo_rule_types_cny2023_goals__WEBPACK_IMPORTED_MODULE_7__[\"default\"](app)); // Rabbit\n\n      app.hero = app.addEntity(new _avo_entity_types_cny2023_rabbit__WEBPACK_IMPORTED_MODULE_1__[\"default\"](app, (_avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_COLS - 1) / 2, 1));\n      app.camera.x = 0;\n      app.camera.y = 0; //app.camera.target = app.hero\n      // Moon\n\n      app.addEntity(new _avo_entity_types_cny2023_moon__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, (_avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_COLS - 1) / 2, CNY2023_CEILING_ROW - 8)); // Ground\n\n      app.addEntity(new _avo_entity_types_cny2023_ground__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_COLS * -0.5, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_ROWS - 1, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_COLS * 2, 16)); // Main boost pad\n\n      this.firstBoostPad = app.addEntity(new _avo_entity_types_cny2023_boost_pad__WEBPACK_IMPORTED_MODULE_4__[\"default\"](app, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_COLS / 2 * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE, // Middle\n      (_avo_constants__WEBPACK_IMPORTED_MODULE_0__.CNY2023_ROWS - 1.5) * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE, FIRST_BOOST_PAD_WIDTH, _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE)); // Bounce pads\n\n      var prevBoostPad = this.firstBoostPad;\n\n      for (var y = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 4; y >= CNY2023_CEILING_Y; y -= _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * ROWS_BETWEEN_BOOSTSPADS) {\n        prevBoostPad = this.createBoostPad(y, prevBoostPad);\n      } // Coins\n\n\n      for (var _y = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 4; _y >= CNY2023_CEILING_Y; _y -= _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * ROWS_BETWEEN_BOOSTSPADS) {\n        this.createCoin(_y + _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2);\n      }\n    }\n  }, {\n    key: \"createBoostPad\",\n    value: function createBoostPad() {\n      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var prevBoostPad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var app = this._app;\n      var BUFFER = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 8;\n      var MIN_WIDTH = 6 * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n      var MAX_WIDTH = 12 * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n      var width = Math.random() * (MAX_WIDTH - MIN_WIDTH) + MIN_WIDTH;\n      var height = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE; // Try to place the new boost pad a small distance away from the previous one\n\n      var MIN_DIST = 2 * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n      var MAX_DIST = 8 * _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n      var distFromPrev = Math.random() * (MAX_DIST - MIN_DIST) + MIN_DIST;\n      var leftOrRight = Math.random() < 0.5 ? -1 : 1;\n      var x = prevBoostPad ? prevBoostPad.x : MID_X;\n      x = x + distFromPrev * leftOrRight;\n      x = Math.min(Math.max(x, MIN_X), MAX_X);\n      var boostPad = app.addEntity(new _avo_entity_types_cny2023_boost_pad__WEBPACK_IMPORTED_MODULE_4__[\"default\"](app, x, y, width, height));\n      var firstPad = this.firstBoostPad; // Make sure the bottom few boost pads don't block the space directly above\n      // the first/initial boost pad.\n\n      if (y >= 0) {\n        if (firstPad.left < boostPad.right && boostPad.right < firstPad.right || firstPad.left < boostPad.x && boostPad.x < firstPad.right) {\n          boostPad.right = this.firstBoostPad.left;\n        } else if (firstPad.left < boostPad.left && boostPad.left < firstPad.right || firstPad.left < boostPad.x && boostPad.x < firstPad.right) {\n          boostPad.left = this.firstBoostPad.right;\n        }\n      }\n\n      return boostPad;\n    }\n  }, {\n    key: \"createCoin\",\n    value: function createCoin() {\n      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      var BUFFER = _avo_constants__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\n      var x = Math.random() * (MAX_X - MIN_X - BUFFER * 2) + MIN_X + BUFFER;\n      app.addEntity(new _avo_entity_types_cny2023_coin__WEBPACK_IMPORTED_MODULE_5__[\"default\"](app, x, y));\n    }\n  }]);\n\n  return Levels;\n}();\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/levels.js?");

/***/ }),

/***/ "./src/avo/misc.js":
/*!*************************!*\
  !*** ./src/avo/misc.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"angleDiff\": () => (/* binding */ angleDiff),\n/* harmony export */   \"isZero\": () => (/* binding */ isZero)\n/* harmony export */ });\n/*\r\nChecks if a number is (close enough) to zero.\r\nDue to the imprecise way floating number data can be stored, it's possible for\r\na mathematical 0 to be represented as something incredibly small like\r\n1.4210854715202004e-14. This screws boolean checks like (num === 0)\r\n */\nfunction isZero(num) {\n  return -1e-10 < num && num < 1e-10;\n}\n/*\r\nFinds the difference between angle B and angle A, in radians.\r\n */\n\nfunction angleDiff(angleA, angleB) {\n  var diff = angleB - angleA; // Clamp diff value to -180º <= x <= +180º\n\n  while (diff < -Math.PI) {\n    diff += Math.PI * 2;\n  } // While diff < -180º, rotate by +360º\n\n\n  while (diff > Math.PI) {\n    diff -= Math.PI * 2;\n  } // While diff > 180º, rotate by -360º\n\n\n  return diff;\n}\n\n//# sourceURL=webpack://cny2023/./src/avo/misc.js?");

/***/ }),

/***/ "./src/avo/physics.js":
/*!****************************!*\
  !*** ./src/avo/physics.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Physics)\n/* harmony export */ });\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/misc */ \"./src/avo/misc.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\nvar USE_CIRCLE_APPROXIMATION = false;\n\nvar Physics = /*#__PURE__*/function () {\n  function Physics() {\n    _classCallCheck(this, Physics);\n  }\n\n  _createClass(Physics, null, [{\n    key: \"checkCollision\",\n    value: //----------------------------------------------------------------\n\n    /*\r\n    Checks if objA is touching objB.\r\n    - If true, returns the corrected coordinates for objA and objB, in form:\r\n      { a: { x, y },\r\n        b: { x, y } }\r\n    - If false, returns null.\r\n     */\n    function checkCollision(objA, objB) {\n      if (!objA || !objB || objA === objB) return null; // Circle + Circle collision\n\n      if (objA.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && objB.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        return Physics.checkCollision_circleCircle(objA, objB);\n      } // Polygon + Polygon collision. (Squares are polygons, of course.)\n      else if ((objA.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objA.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) && (objB.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objB.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n        return Physics.checkCollision_polygonPolygon(objA, objB);\n      } // Circle + Polygon collision.\n      else if (objA.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && (objB.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objB.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        return Physics.checkCollision_circlePolygon(objA, objB);\n      } // Polygon + Circle collision\n      // It's the reverse of the previous scenario.\n      else if ((objA.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objA.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) && objB.shape === _avo_constants__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        var correction = Physics.checkCollision_circlePolygon(objB, objA);\n\n        if (correction) {\n          correction = {\n            a: correction.b,\n            b: correction.a\n          };\n        }\n\n        return correction;\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_circleCircle\",\n    value: function checkCollision_circleCircle(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var minimumDist = objA.radius + objB.radius;\n\n      if (dist < minimumDist) {\n        var angle = Math.atan2(distY, distX);\n        var correctDist = minimumDist;\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n        var motion = Physics.getPostCollisionMotion(objA, objB);\n        return {\n          a: {\n            x: objA.x - cosAngle * (correctDist - dist) * fractionA,\n            y: objA.y - sinAngle * (correctDist - dist) * fractionA,\n            pushX: motion && motion.a.pushX,\n            pushY: motion && motion.a.pushY\n          },\n          b: {\n            x: objB.x + cosAngle * (correctDist - dist) * fractionB,\n            y: objB.y + sinAngle * (correctDist - dist) * fractionB,\n            pushX: motion && motion.b.pushX,\n            pushY: motion && motion.b.pushY\n          }\n        };\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_polygonPolygon\",\n    value: function checkCollision_polygonPolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var correction = null;\n      var verticesA = objA.vertices;\n      var verticesB = objB.vertices;\n      var projectionAxes = [].concat(_toConsumableArray(Physics.getShapeNormals(objA)), _toConsumableArray(Physics.getShapeNormals(objB)));\n\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var projectionA = {\n          min: Infinity,\n          max: -Infinity\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n\n        for (var j = 0; j < verticesA.length; j++) {\n          var val = Physics.dotProduct(axis, verticesA[j]);\n          projectionA.min = Math.min(projectionA.min, val);\n          projectionA.max = Math.max(projectionA.max, val);\n        }\n\n        for (var _j = 0; _j < verticesB.length; _j++) {\n          var _val = Physics.dotProduct(axis, verticesB[_j]);\n\n          projectionB.min = Math.min(projectionB.min, _val);\n          projectionB.max = Math.max(projectionB.max, _val);\n        }\n\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n\n      if (correction && correction.magnitude > 0) {\n        return {\n          a: {\n            x: objA.x - correction.x * fractionA,\n            y: objA.y - correction.y * fractionA\n          },\n          b: {\n            x: objB.x + correction.x * fractionB,\n            y: objB.y + correction.y * fractionB\n          }\n        };\n      }\n\n      return null;\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"checkCollision_circlePolygon\",\n    value: function checkCollision_circlePolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n\n      if (!objA.solid || !objB.solid) {//If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var angle = Math.atan2(distY, distX);\n      var centreToCentreAxis = dist !== 0 ? {\n        x: distX / dist,\n        y: distY / dist\n      } : {\n        x: 0,\n        y: 0\n      };\n      var correction = null;\n      var verticesB = objB.vertices;\n      var projectionAxes = [centreToCentreAxis].concat(_toConsumableArray(Physics.getShapeNormals(objB)));\n\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var scalarA = Physics.dotProduct(axis, {\n          x: objA.x,\n          y: objA.y\n        });\n        var projectionA = {\n          min: scalarA - objA.radius,\n          max: scalarA + objA.radius\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n\n        for (var j = 0; j < verticesB.length; j++) {\n          var val = Physics.dotProduct(axis, verticesB[j]);\n          projectionB.min = Math.min(projectionB.min, val);\n          projectionB.max = Math.max(projectionB.max, val);\n        }\n\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n\n      if (correction && correction.magnitude > 0) {\n        return {\n          a: {\n            x: objA.x - correction.x * fractionA,\n            y: objA.y - correction.y * fractionA\n          },\n          b: {\n            x: objB.x + correction.x * fractionB,\n            y: objB.y + correction.y * fractionB\n          }\n        };\n      }\n    } //----------------------------------------------------------------\n\n    /*  Gets the NORMALISED normals for each edge of the object's shape. Assumes the object has the 'vertices' property.\r\n     */\n\n  }, {\n    key: \"getShapeNormals\",\n    value: function getShapeNormals(obj) {\n      var vertices = obj.vertices;\n      if (!vertices) return null;\n      if (vertices.length < 2) return []; //Look, you need to have at least three vertices to be a shape.\n      //First, calculate the edges connecting each vertice.\n      //--------------------------------\n\n      var edges = [];\n\n      for (var i = 0; i < vertices.length; i++) {\n        var p1 = vertices[i];\n        var p2 = vertices[(i + 1) % vertices.length];\n        edges.push({\n          x: p2.x - p1.x,\n          y: p2.y - p1.y\n        });\n      } //--------------------------------\n      //Calculate the NORMALISED normals for each edge.\n      //--------------------------------\n\n\n      return edges.map(function (edge) {\n        var dist = Math.sqrt(edge.x * edge.x + edge.y * edge.y);\n        if (dist === 0) return {\n          x: 0,\n          y: 0\n        };\n        return {\n          x: -edge.y / dist,\n          y: edge.x / dist\n        };\n      }); //--------------------------------\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"getPostCollisionMotion\",\n    value: function getPostCollisionMotion(objA, objB) {\n      if (!objA || !objB) return null;\n      if (!objA.movable || !objA.solid || objA.mass === 0 || !objB.movable || !objB.solid || objB.mass === 0 || objA.mass + objB.mass === 0) return null;\n      var collisionAngle = Math.atan2(objB.y - objA.y, objB.x - objA.x);\n      var ANGLE_90 = Math.PI / 2;\n      var totalMass = objA.mass + objB.mass;\n      var aSpd = objA.pushSpeed;\n      var bSpd = objB.pushSpeed;\n      var aAng = objA.pushAngle;\n      var bAng = objB.pushAngle;\n      var aMass = objA.mass;\n      var bMass = objB.mass;\n      var aGroup = (aSpd * Math.cos(aAng - collisionAngle) * (aMass - bMass) + 2 * bMass * bSpd * Math.cos(bAng - collisionAngle)) / totalMass;\n      var bGroup = (bSpd * Math.cos(bAng - collisionAngle) * (bMass - aMass) + 2 * aMass * aSpd * Math.cos(aAng - collisionAngle)) / totalMass;\n      var objA_pushX = aGroup * Math.cos(collisionAngle) + aSpd * Math.sin(aAng - collisionAngle) * Math.cos(collisionAngle + ANGLE_90);\n      var objA_pushY = aGroup * Math.sin(collisionAngle) + aSpd * Math.sin(aAng - collisionAngle) * Math.sin(collisionAngle + ANGLE_90);\n      var objB_pushX = bGroup * Math.cos(collisionAngle) + bSpd * Math.sin(bAng - collisionAngle) * Math.cos(collisionAngle + ANGLE_90);\n      var objB_pushY = bGroup * Math.sin(collisionAngle) + bSpd * Math.sin(bAng - collisionAngle) * Math.sin(collisionAngle + ANGLE_90);\n      return {\n        a: {\n          pushX: objA_pushX,\n          pushY: objA_pushY\n        },\n        b: {\n          pushX: objB_pushX,\n          pushY: objB_pushY\n        }\n      };\n    } //----------------------------------------------------------------\n\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(vectorA, vectorB) {\n      if (!vectorA || !vectorB) return null;\n      return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n    } //----------------------------------------------------------------\n\n    /*\r\n    Calculate intersection between two lines (a ray and a segment of a polygon).\r\n    Useful for determining valids line of sight.\r\n      - Each line is in the format { start: { x, y }, end: { x, y } }\r\n    - Returns null if there's no intersection.\r\n    - Returns { x, y, distanceFactor } if there's an intersection.\r\n      x, y are the coordinates of the intersection point.\r\n      distanceFactor is how far from the ray's origin point the intersection\r\n      occurs. If 1, intersection occurs at the ray's end point. If 0.5,\r\n      intersection occurs halfway between the ray's origin point and end point.\r\n      Original code from https://ncase.me/sight-and-light/\r\n     */\n\n  }, {\n    key: \"getLineIntersection\",\n    value: function getLineIntersection(ray, segment) {\n      // Each line is represented in the format:\n      // line = originPoint + directionVector * distanceFactor\n      // Or a bit more simply:\n      // line = origin (o) + direction (d) * factor (f)\n      // Ray\n      var r_ox = ray.start.x;\n      var r_oy = ray.start.y;\n      var r_dx = ray.end.x - ray.start.x;\n      var r_dy = ray.end.y - ray.start.y; // Segment\n\n      var s_ox = segment.start.x;\n      var s_oy = segment.start.y;\n      var s_dx = segment.end.x - segment.start.x;\n      var s_dy = segment.end.y - segment.start.y; // The intersection occurs where ray.x === segment.x and ray.y === segment.y\n      // So, we need to solve for r_factor and s_factor in...\n      // r_ox + r_dx * r_factor = s_ox + s_dx * s_factor && r_oy + r_dy * r_factor = s_oy + s_dy * s_factor\n\n      var r_factor = null;\n      var s_factor = null;\n\n      if (!(0,_avo_misc__WEBPACK_IMPORTED_MODULE_1__.isZero)(s_dx * r_dy - s_dy * r_dx)) {\n        // Solve for s_factor.\n        s_factor = (r_dx * (s_oy - r_oy) + r_dy * (r_ox - s_ox)) / (s_dx * r_dy - s_dy * r_dx); // There are two ways to solve for r_factor; one works when the ray\n        // isn't perfectly horizontal, the other works when the ray isn't\n        // perfectly vertical.\n\n        if (!(0,_avo_misc__WEBPACK_IMPORTED_MODULE_1__.isZero)(r_dx)) {\n          r_factor = (s_ox + s_dx * s_factor - r_ox) / r_dx;\n        } else if (!(0,_avo_misc__WEBPACK_IMPORTED_MODULE_1__.isZero)(r_dy)) {\n          r_factor = (s_oy + s_dy * s_factor - r_oy) / r_dy;\n        }\n      } // Check if the intersection occurs within the length of both lines.\n      // (The maths above calculates for infinitely long lines.)\n\n\n      if (r_factor === null || s_factor === null || r_factor < 0 || r_factor > 1 || s_factor < 0 || s_factor > 1) return null; // Point of intersection\n\n      return {\n        x: r_ox + r_dx * r_factor,\n        y: r_oy + r_dy * r_factor,\n        distanceFactor: r_factor\n      };\n    } //----------------------------------------------------------------\n\n  }]);\n\n  return Physics;\n}();\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/physics.js?");

/***/ }),

/***/ "./src/avo/rule/index.js":
/*!*******************************!*\
  !*** ./src/avo/rule/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rule */ \"./src/avo/rule/rule.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2023/./src/avo/rule/index.js?");

/***/ }),

/***/ "./src/avo/rule/rule.js":
/*!******************************!*\
  !*** ./src/avo/rule/rule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rule)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar Rule = /*#__PURE__*/function () {\n  function Rule(app) {\n    _classCallCheck(this, Rule);\n\n    this._app = app;\n    this._type = 'rule';\n    this.name = ''; // Optional identifier\n    // Expired rules are removed at the end of the cycle.\n\n    this._expired = false;\n  }\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n\n\n  _createClass(Rule, [{\n    key: \"play\",\n    value: function play(timeStep) {}\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    }\n  }]);\n\n  return Rule;\n}();\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/rule/rule.js?");

/***/ }),

/***/ "./src/avo/rule/types/cny2023-controls.js":
/*!************************************************!*\
  !*** ./src/avo/rule/types/cny2023-controls.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CNY2023Controls)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar MIN_X = 0;\nvar MAX_X = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_COLS * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\nvar MIN_RABBIT_X = MIN_X + _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\nvar MAX_RABBIT_X = MAX_X - _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\nvar MAX_Y = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_ROWS * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n\nvar CNY2023Controls = /*#__PURE__*/function (_Rule) {\n  _inherits(CNY2023Controls, _Rule);\n\n  var _super = _createSuper(CNY2023Controls);\n\n  function CNY2023Controls(app) {\n    var _this;\n\n    _classCallCheck(this, CNY2023Controls);\n\n    _this = _super.call(this, app);\n    _this._type = 'cny2023-controls';\n    _this.stars = _this.generateStars();\n    return _this;\n  }\n\n  _createClass(CNY2023Controls, [{\n    key: \"play\",\n    value: function play(timeStep) {\n      var app = this._app;\n      var entities = app.entities;\n      var TIME_MODIFIER = timeStep / _avo_constants__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_TIMESTEP; // Gravity\n\n      entities.forEach(function (entity) {\n        if (entity.movable) {\n          entity.pushY += _avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_GRAVITY / TIME_MODIFIER;\n        }\n      });\n      this.checkUserInput(timeStep);\n      this.checkRabbitPosition();\n      this.focusCamera();\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      var hero = app.hero;\n      var camera = app.camera;\n      var c2d = app.canvas2d;\n\n      if (layer === _avo_constants__WEBPACK_IMPORTED_MODULE_1__.LAYERS.BACKGROUND) {\n        // Paint sky\n        // ----------------\n        var gradient = c2d.createLinearGradient(0, 0, 0, 640);\n        gradient.addColorStop(0, '#404040');\n        gradient.addColorStop(1, '#6080a0');\n        c2d.fillStyle = gradient;\n        c2d.fillRect(0, 0, 1280, 640); // ----------------\n        // Paint stars\n\n        c2d.fillStyle = '#fff';\n        this.stars.forEach(function (star) {\n          c2d.beginPath();\n          c2d.arc(star.x, star.y, star.size / 2, 0, 2 * Math.PI);\n          c2d.closePath();\n          c2d.fill();\n        });\n      }\n    }\n  }, {\n    key: \"checkUserInput\",\n    value: function checkUserInput(timeStep) {\n      var app = this._app;\n      var hero = app.hero;\n      var _app$playerInput = app.playerInput,\n          keysPressed = _app$playerInput.keysPressed,\n          buttonArrowLeftPressed = _app$playerInput.buttonArrowLeftPressed,\n          buttonArrowRightPressed = _app$playerInput.buttonArrowRightPressed;\n      var TIME_MODIFIER = timeStep / _avo_constants__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_TIMESTEP;\n      if (!hero) return;\n\n      if (keysPressed['ArrowLeft'] || buttonArrowLeftPressed) {\n        hero.pushX -= _avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_RABBIT_SPEED / TIME_MODIFIER;\n        hero.direction = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.WEST;\n      }\n\n      if (keysPressed['ArrowRight'] || buttonArrowRightPressed) {\n        hero.pushX += _avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_RABBIT_SPEED / TIME_MODIFIER;\n        hero.direction = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.EAST;\n      }\n    }\n  }, {\n    key: \"focusCamera\",\n    value: function focusCamera() {\n      var app = this._app;\n      var hero = app.hero;\n      var camera = app.camera;\n\n      if (hero) {\n        camera.x = camera.zoom <= 1 ? app.canvasWidth / 2 - app.canvasWidth / 2 * camera.zoom : app.canvasWidth / 2 - hero.x * camera.zoom;\n        camera.y = app.canvasHeight / 2 - hero.y * camera.zoom; // Clamp to viewable space\n\n        camera.y = Math.max(camera.y, 0);\n      }\n    }\n  }, {\n    key: \"checkRabbitPosition\",\n    value: function checkRabbitPosition() {\n      var app = this._app;\n      var hero = app.hero;\n      var goals = app.rules['cny2023-goals'];\n      if (!hero || !goals) return;\n      hero.x = Math.max(hero.x, MIN_RABBIT_X);\n      hero.x = Math.min(hero.x, MAX_RABBIT_X);\n      if (hero.y > MAX_Y) goals.triggerLoseScreen();\n    }\n  }, {\n    key: \"generateStars\",\n    value: function generateStars() {\n      var stars = [];\n      var app = this._app;\n\n      for (var i = 0; i < 100; i++) {\n        var x = Math.random() * app.canvasWidth;\n        var y = Math.random() * Math.random() * app.canvasHeight;\n        var size = 2;\n        stars.push({\n          x: x,\n          y: y,\n          size: size\n        });\n      }\n\n      return stars;\n    }\n  }]);\n\n  return CNY2023Controls;\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/rule/types/cny2023-controls.js?");

/***/ }),

/***/ "./src/avo/rule/types/cny2023-goals.js":
/*!*********************************************!*\
  !*** ./src/avo/rule/types/cny2023-goals.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CNY2023Goals)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants */ \"./src/avo/constants.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar ANIMATION_MID = 200;\nvar ANIMATION_MAX = 5000;\nvar MIN_X = 0;\nvar MIN_Y = 0;\nvar MAX_X = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_COLS * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE; // Canvas width\n\nvar MAX_Y = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_ROWS * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE; // Canvas height\n\nvar IMAGE_WIDTH = 1280;\nvar IMAGE_HEIGHT = 640;\nvar HUD_SCREEN_EDGE_X_OFFSET = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 1.5;\nvar HUD_SCREEN_EDGE_Y_OFFSET = _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * -1.0;\nvar FLOOR_HEIGHT_OFFSET = (_avo_constants__WEBPACK_IMPORTED_MODULE_1__.CNY2023_ROWS - 1.5) * _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n/*\r\nThis Rule keeps track of scores and the win/lose condition.\r\n */\n\nvar CNY2023Goals = /*#__PURE__*/function (_Rule) {\n  _inherits(CNY2023Goals, _Rule);\n\n  var _super = _createSuper(CNY2023Goals);\n\n  function CNY2023Goals(app) {\n    var _this;\n\n    _classCallCheck(this, CNY2023Goals);\n\n    _this = _super.call(this, app);\n    _this._type = 'cny2023-goals';\n    _this.win = false;\n    _this.lose = false;\n    _this.animationCounter = 0;\n    _this.score = 0;\n    return _this;\n  }\n\n  _createClass(CNY2023Goals, [{\n    key: \"play\",\n    value: function play(timeStep) {\n      if (this.win || this.lose) {\n        this.animationCounter = Math.min(this.animationCounter + timeStep, ANIMATION_MAX);\n      }\n\n      if (this.animationCounter >= ANIMATION_MAX) {// TODO: show home screen\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer !== _avo_constants__WEBPACK_IMPORTED_MODULE_1__.LAYERS.HUD) return;\n      var app = this._app;\n      var hero = app.hero;\n      var c2d = app.canvas2d;\n      var imageAsset = undefined;\n\n      if (!this.win && !this.lose) {\n        // Paint the current score\n        // ----------------\n        var LEFT = HUD_SCREEN_EDGE_X_OFFSET;\n        var RIGHT = app.canvasWidth - HUD_SCREEN_EDGE_X_OFFSET;\n        var BOTTOM = app.canvasHeight + HUD_SCREEN_EDGE_Y_OFFSET;\n        c2d.font = '2em Source Code Pro';\n        c2d.textBaseline = 'bottom';\n        c2d.lineWidth = 8;\n        var jumpHeight = hero ? FLOOR_HEIGHT_OFFSET - hero.y : 0;\n        var jumpHeightInMetres = jumpHeight / _avo_constants__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n        var text = \"\".concat(jumpHeightInMetres.toFixed(0), \"m\");\n        c2d.textAlign = 'right';\n        c2d.strokeStyle = '#fff';\n        c2d.strokeText(text, RIGHT, BOTTOM);\n        c2d.fillStyle = '#c44';\n        c2d.fillText(text, RIGHT, BOTTOM);\n        text = \"Score: \".concat(this.score);\n        c2d.textAlign = 'left';\n        c2d.strokeStyle = '#fff';\n        c2d.strokeText(text, LEFT, BOTTOM);\n        c2d.fillStyle = '#c44';\n        c2d.fillText(text, LEFT, BOTTOM); // ----------------\n      } else {\n        // Paint Win or Lose screens\n        // ----------------\n        if (this.win) imageAsset = app.assets['win'];\n        if (this.lose) imageAsset = app.assets['lose'];\n        if (!imageAsset) return;\n        var progress = Math.min(this.animationCounter / ANIMATION_MID, 1.0);\n        var sizeFactor = progress * 0.6 + 0.2;\n        var sizeX = IMAGE_WIDTH * sizeFactor;\n        var sizeY = IMAGE_HEIGHT * sizeFactor;\n        var tgtX = (MAX_X - sizeX) / 2;\n        var tgtY = (MAX_Y - sizeY) / 2;\n        c2d.drawImage(imageAsset.img, tgtX, tgtY, sizeX, sizeY); // ----------------\n      }\n    }\n  }, {\n    key: \"triggerWinScreen\",\n    value: function triggerWinScreen() {\n      if (this.win || this.lose) return; // Don't trigger more than once\n\n      this.win = true;\n      console.log('WIN');\n    }\n  }, {\n    key: \"triggerLoseScreen\",\n    value: function triggerLoseScreen() {\n      if (this.win || this.lose) return; // Don't trigger more than once\n\n      this.lose = true;\n      console.log('LOSE');\n    }\n  }, {\n    key: \"increaseScore\",\n    value: function increaseScore() {\n      if (this.win || this.lose) return;\n      this.score++;\n    }\n  }]);\n\n  return CNY2023Goals;\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://cny2023/./src/avo/rule/types/cny2023-goals.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo */ \"./src/avo/index.js\");\n\nvar cny2023;\n\nwindow.onload = function () {\n  window.cny2023 = new _avo__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n};\n\n//# sourceURL=webpack://cny2023/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;